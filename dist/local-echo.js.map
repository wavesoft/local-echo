{"version":3,"file":"local-echo.js","mappings":"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","sources":["webpack://LocalEchoController/./node_modules/shell-quote/index.js","webpack://LocalEchoController/./node_modules/shell-quote/parse.js","webpack://LocalEchoController/./node_modules/shell-quote/quote.js","webpack://LocalEchoController/webpack/bootstrap","webpack://LocalEchoController/webpack/runtime/define property getters","webpack://LocalEchoController/webpack/runtime/hasOwnProperty shorthand","webpack://LocalEchoController/./lib/HistoryController.js","webpack://LocalEchoController/./lib/Utils.js","webpack://LocalEchoController/./lib/LocalEchoController.js","webpack://LocalEchoController/./index.js"],"sourcesContent":["'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n","'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|',\n\t'\\\\&\\\\&',\n\t';;',\n\t'\\\\|\\\\&',\n\t'\\\\<\\\\(',\n\t'\\\\<\\\\<\\\\<',\n\t'>>',\n\t'>\\\\&',\n\t'<\\\\&',\n\t'[&;()|<>]'\n].join('|') + ')';\nvar controlRE = new RegExp('^' + CONTROL + '$');\nvar META = '|&;()<> \\\\t';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar hash = /^#$/;\n\nvar SQ = \"'\";\nvar DQ = '\"';\nvar DS = '$';\n\nvar TOKEN = '';\nvar mult = 0x100000000; // Math.pow(16, 8);\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (mult * Math.random()).toString(16);\n}\nvar startsWithToken = new RegExp('^' + TOKEN);\n\nfunction matchAll(s, r) {\n\tvar origIndex = r.lastIndex;\n\n\tvar matches = [];\n\tvar matchObj;\n\n\twhile ((matchObj = r.exec(s))) {\n\t\tmatches.push(matchObj);\n\t\tif (r.lastIndex === matchObj.index) {\n\t\t\tr.lastIndex += 1;\n\t\t}\n\t}\n\n\tr.lastIndex = origIndex;\n\n\treturn matches;\n}\n\nfunction getVar(env, pre, key) {\n\tvar r = typeof env === 'function' ? env(key) : env[key];\n\tif (typeof r === 'undefined' && key != '') {\n\t\tr = '';\n\t} else if (typeof r === 'undefined') {\n\t\tr = '$';\n\t}\n\n\tif (typeof r === 'object') {\n\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t}\n\treturn pre + r;\n}\n\nfunction parseInternal(string, env, opts) {\n\tif (!opts) {\n\t\topts = {};\n\t}\n\tvar BS = opts.escape || '\\\\';\n\tvar BAREWORD = '(\\\\' + BS + '[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\n\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')+'\n\t].join('|'), 'g');\n\n\tvar matches = matchAll(string, chunker);\n\n\tif (matches.length === 0) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\n\tvar commented = false;\n\n\treturn matches.map(function (match) {\n\t\tvar s = match[0];\n\t\tif (!s || commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (controlRE.test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\tvar char = s.charAt(i);\n\n\t\t\tif (char === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i - 2, i + 1));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.slice(i, varend);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(char)) {\n\t\t\t\tvarname = char;\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvar slicedFromI = s.slice(i);\n\t\t\t\tvarend = slicedFromI.match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = slicedFromI;\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = slicedFromI.slice(0, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(env, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (controlRE.test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if (hash.test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tvar commentObj = { comment: string.slice(match.index + i + 1) };\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, commentObj];\n\t\t\t\t}\n\t\t\t\treturn [commentObj];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed arguments\n\t\t// TODO: replace this whole reduce with a concat\n\t\treturn typeof arg === 'undefined' ? prev : prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (startsWithToken.test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n","'use strict';\n\nmodule.exports = function quote(xs) {\n\treturn xs.map(function (s) {\n\t\tif (s && typeof s === 'object') {\n\t\t\treturn s.op.replace(/(.)/g, '\\\\$1');\n\t\t}\n\t\tif ((/[\"\\s]/).test(s) && !(/'/).test(s)) {\n\t\t\treturn \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n\t\t}\n\t\tif ((/[\"'\\s]/).test(s)) {\n\t\t\treturn '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n\t\t}\n\t\treturn String(s).replace(/([A-Za-z]:)?([#!\"$&'()*,:;<=>?@[\\\\\\]^`{|}])/g, '$1\\\\$2');\n\t}).join(' ');\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\r\n * The history controller provides an ring-buffer\r\n */\r\nexport class HistoryController {\r\n  constructor(size) {\r\n    this.size = size;\r\n    this.entries = [];\r\n    this.cursor = 0;\r\n  }\r\n\r\n  /**\r\n   * Push an entry and maintain ring buffer size\r\n   */\r\n  push(entry) {\r\n    // Skip empty entries\r\n    if (entry.trim() === \"\") return;\r\n    // Skip duplicate entries\r\n    const lastEntry = this.entries[this.entries.length - 1];\r\n    if (entry == lastEntry) return;\r\n    // Keep track of entries\r\n    this.entries.push(entry);\r\n    if (this.entries.length > this.size) {\r\n      this.entries.pop(0);\r\n    }\r\n    this.cursor = this.entries.length;\r\n  }\r\n\r\n  /**\r\n   * Rewind history cursor on the last entry\r\n   */\r\n  rewind() {\r\n    this.cursor = this.entries.length;\r\n  }\r\n\r\n  /**\r\n   * Returns the previous entry\r\n   */\r\n  getPrevious() {\r\n    const idx = Math.max(0, this.cursor - 1);\r\n    this.cursor = idx;\r\n    return this.entries[idx];\r\n  }\r\n\r\n  /**\r\n   * Returns the next entry\r\n   */\r\n  getNext() {\r\n    const idx = Math.min(this.entries.length, this.cursor + 1);\r\n    this.cursor = idx;\r\n    return this.entries[idx];\r\n  }\r\n}\r\n","import { parse } from \"shell-quote\";\r\n\r\n/**\r\n * Detects all the word boundaries on the given input\r\n */\r\nexport function wordBoundaries(input, leftSide = true) {\r\n  let match;\r\n  const words = [];\r\n  const rx = /\\w+/g;\r\n\r\n  while ((match = rx.exec(input))) {\r\n    if (leftSide) {\r\n      words.push(match.index);\r\n    } else {\r\n      words.push(match.index + match[0].length);\r\n    }\r\n  }\r\n\r\n  return words;\r\n}\r\n\r\n/**\r\n * The closest left (or right) word boundary of the given input at the\r\n * given offset.\r\n */\r\nexport function closestLeftBoundary(input, offset) {\r\n  const found = wordBoundaries(input, true)\r\n    .reverse()\r\n    .find(x => x < offset);\r\n  return found == null ? 0 : found;\r\n}\r\nexport function closestRightBoundary(input, offset) {\r\n  const found = wordBoundaries(input, false).find(x => x > offset);\r\n  return found == null ? input.length : found;\r\n}\r\n\r\n/**\r\n * Convert offset at the given input to col/row location\r\n *\r\n * This function is not optimized and practically emulates via brute-force\r\n * the navigation on the terminal, wrapping when they reach the column width.\r\n */\r\nexport function offsetToColRow(input, offset, maxCols) {\r\n  let row = 0,\r\n    col = 0;\r\n\r\n  for (let i = 0; i < offset; ++i) {\r\n    const chr = input.charAt(i);\r\n    if (chr == \"\\n\") {\r\n      col = 0;\r\n      row += 1;\r\n    } else {\r\n      col += 1;\r\n      if (col > maxCols) {\r\n        col = 0;\r\n        row += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  return { row, col };\r\n}\r\n\r\n/**\r\n * Counts the lines in the given input\r\n */\r\nexport function countLines(input, maxCols) {\r\n  return offsetToColRow(input, input.length, maxCols).row + 1;\r\n}\r\n\r\n/**\r\n * Checks if there is an incomplete input\r\n *\r\n * An incomplete input is considered:\r\n * - An input that contains unterminated single quotes\r\n * - An input that contains unterminated double quotes\r\n * - An input that ends with \"\\\"\r\n * - An input that has an incomplete boolean shell expression (&& and ||)\r\n * - An incomplete pipe expression (|)\r\n */\r\nexport function isIncompleteInput(input) {\r\n  // Empty input is not incomplete\r\n  if (input.trim() == \"\") {\r\n    return false;\r\n  }\r\n\r\n  // Check for dangling single-quote strings\r\n  if ((input.match(/'/g) || []).length % 2 !== 0) {\r\n    return true;\r\n  }\r\n  // Check for dangling double-quote strings\r\n  if ((input.match(/\"/g) || []).length % 2 !== 0) {\r\n    return true;\r\n  }\r\n  // Check for dangling boolean or pipe operations\r\n  if (\r\n    input\r\n      .split(/(\\|\\||\\||&&)/g)\r\n      .pop()\r\n      .trim() == \"\"\r\n  ) {\r\n    return true;\r\n  }\r\n  // Check for tailing slash\r\n  if (input.endsWith(\"\\\\\") && !input.endsWith(\"\\\\\\\\\")) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Returns true if the expression ends on a tailing whitespace\r\n */\r\nexport function hasTailingWhitespace(input) {\r\n  return input.match(/[^\\\\][ \\t]$/m) != null;\r\n}\r\n\r\n/**\r\n * Returns the last expression in the given input\r\n */\r\nexport function getLastToken(input) {\r\n  // Empty expressions\r\n  if (input.trim() === \"\") return \"\";\r\n  if (hasTailingWhitespace(input)) return \"\";\r\n\r\n  // Last token\r\n  const tokens = parse(input);\r\n  return tokens.pop() || \"\";\r\n}\r\n\r\n/**\r\n * Returns the auto-complete candidates for the given input\r\n */\r\nexport function collectAutocompleteCandidates(callbacks, input) {\r\n  const tokens = parse(input);\r\n  let index = tokens.length - 1;\r\n  let expr = tokens[index] || \"\";\r\n\r\n  // Empty expressions\r\n  if (input.trim() === \"\") {\r\n    index = 0;\r\n    expr = \"\";\r\n  } else if (hasTailingWhitespace(input)) {\r\n    // Expressions with danging space\r\n    index += 1;\r\n    expr = \"\";\r\n  }\r\n\r\n  // Collect all auto-complete candidates from the callbacks\r\n  const all = callbacks.reduce((candidates, { fn, args }) => {\r\n    try {\r\n      return candidates.concat(fn(index, tokens, ...args));\r\n    } catch (e) {\r\n      console.error(\"Auto-complete error:\", e);\r\n      return candidates;\r\n    }\r\n  }, []);\r\n\r\n  // Filter only the ones starting with the expression\r\n  return all.filter(txt => txt.startsWith(expr));\r\n}\r\n\r\n\r\nexport function getSharedFragment(fragment, candidates) {\r\n\r\n  // end loop when fragment length = first candidate length\r\n  if (fragment.length >= candidates[0].length) return fragment;\r\n  \r\n  // save old fragemnt\r\n  const oldFragment = fragment;\r\n  \r\n  // get new fragment\r\n  fragment += candidates[0].slice(fragment.length, fragment.length+1);\r\n\r\n  for (let i=0; i<candidates.length; i++ ) {\r\n\r\n    // return null when there's a wrong candidate\r\n    if (!candidates[i].startsWith(oldFragment)) return null;\r\n\r\n    if (!candidates[i].startsWith(fragment)) {\r\n      return oldFragment;\r\n    }\r\n  }\r\n\r\n  return getSharedFragment(fragment, candidates);\r\n}\r\n","import { HistoryController } from \"./HistoryController\";\r\nimport {\r\n  closestLeftBoundary,\r\n  closestRightBoundary,\r\n  collectAutocompleteCandidates,\r\n  countLines,\r\n  getLastToken,\r\n  hasTailingWhitespace,\r\n  isIncompleteInput,\r\n  offsetToColRow,\r\n  getSharedFragment\r\n} from \"./Utils\";\r\n\r\n/**\r\n * A local terminal controller is responsible for displaying messages\r\n * and handling local echo for the terminal.\r\n *\r\n * Local echo supports most of bash-like input primitives. Namely:\r\n * - Arrow navigation on the input\r\n * - Alt-arrow for word-boundary navigation\r\n * - Alt-backspace for word-boundary deletion\r\n * - Multi-line input for incomplete commands\r\n * - Auto-complete hooks\r\n */\r\nexport default class LocalEchoController {\r\n  constructor(term = null, options = {}) {\r\n    this.term = term;\r\n    this._handleTermData = this.handleTermData.bind(this);\r\n    this._handleTermResize = this.handleTermResize.bind(this)\r\n    \r\n    this.history = new HistoryController(options.historySize || 10);\r\n    this.maxAutocompleteEntries = options.maxAutocompleteEntries || 100;\r\n\r\n    this._autocompleteHandlers = [];\r\n    this._active = false;\r\n    this._input = \"\";\r\n    this._cursor = 0;\r\n    this._activePrompt = null;\r\n    this._activeCharPrompt = null;\r\n    this._termSize = {\r\n      cols: 0,\r\n      rows: 0,\r\n    };\r\n\r\n    this._disposables = [];\r\n    \r\n    if (term) {\r\n      if (term.loadAddon) term.loadAddon(this);\r\n      else this.attach();\r\n    }\r\n  }\r\n\r\n  // xterm.js new plugin API:\r\n  activate(term) {\r\n    this.term = term;\r\n    this.attach();\r\n  }\r\n  dispose() {\r\n    this.detach();\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  // User-Facing API\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  \r\n  /**\r\n   *  Detach the controller from the terminal\r\n   */\r\n  detach() {\r\n    if (this.term.off) {\r\n      this.term.off(\"data\", this._handleTermData);\r\n      this.term.off(\"resize\", this._handleTermResize);\r\n    } else {\r\n      this._disposables.forEach(d => d.dispose());\r\n      this._disposables = [];\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Attach controller to the terminal, handling events\r\n   */\r\n  attach() {\r\n    if (this.term.on) {\r\n      this.term.on(\"data\", this._handleTermData);\r\n      this.term.on(\"resize\", this._handleTermResize);\r\n    } else {\r\n      this._disposables.push(this.term.onData(this._handleTermData));\r\n      this._disposables.push(this.term.onResize(this._handleTermResize));\r\n    }\r\n    this._termSize = {\r\n      cols: this.term.cols,\r\n      rows: this.term.rows,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Register a handler that will be called to satisfy auto-completion\r\n   */\r\n  addAutocompleteHandler(fn, ...args) {\r\n    this._autocompleteHandlers.push({\r\n      fn,\r\n      args\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Remove a previously registered auto-complete handler\r\n   */\r\n  removeAutocompleteHandler(fn) {\r\n    const idx = this._autocompleteHandlers.findIndex(e => e.fn === fn);\r\n    if (idx === -1) return;\r\n\r\n    this._autocompleteHandlers.splice(idx, 1);\r\n  }\r\n\r\n  /**\r\n   * Return a promise that will resolve when the user has completed\r\n   * typing a single line\r\n   */\r\n  read(prompt, continuationPrompt = \"> \") {\r\n    return new Promise((resolve, reject) => {\r\n      this.term.write(prompt);\r\n      this._activePrompt = {\r\n        prompt,\r\n        continuationPrompt,\r\n        resolve,\r\n        reject\r\n      };\r\n\r\n      this._input = \"\";\r\n      this._cursor = 0;\r\n      this._active = true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Return a promise that will be resolved when the user types a single\r\n   * character.\r\n   *\r\n   * This can be active in addition to `.read()` and will be resolved in\r\n   * priority before it.\r\n   */\r\n  readChar(prompt) {\r\n    return new Promise((resolve, reject) => {\r\n      this.term.write(prompt);\r\n      this._activeCharPrompt = {\r\n        prompt,\r\n        resolve,\r\n        reject\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Abort a pending read operation\r\n   */\r\n  abortRead(reason = \"aborted\") {\r\n    if (this._activePrompt != null || this._activeCharPrompt != null) {\r\n      this.term.write(\"\\r\\n\");\r\n    }\r\n    if (this._activePrompt != null) {\r\n      this._activePrompt.reject(reason);\r\n      this._activePrompt = null;\r\n    }\r\n    if (this._activeCharPrompt != null) {\r\n      this._activeCharPrompt.reject(reason);\r\n      this._activeCharPrompt = null;\r\n    }\r\n    this._active = false;\r\n  }\r\n\r\n  /**\r\n   * Prints a message and changes line\r\n   */\r\n  println(message) {\r\n    this.print(message + \"\\n\");\r\n  }\r\n\r\n  /**\r\n   * Prints a message and properly handles new-lines\r\n   */\r\n  print(message) {\r\n    const normInput = message.replace(/[\\r\\n]+/g, \"\\n\");\r\n    this.term.write(normInput.replace(/\\n/g, \"\\r\\n\"));\r\n  }\r\n\r\n  /**\r\n   * Prints a list of items using a wide-format\r\n   */\r\n  printWide(items, padding = 2) {\r\n    if (items.length == 0) return println(\"\");\r\n\r\n    // Compute item sizes and matrix row/cols\r\n    const itemWidth =\r\n      items.reduce((width, item) => Math.max(width, item.length), 0) + padding;\r\n    const wideCols = Math.floor(this._termSize.cols / itemWidth);\r\n    const wideRows = Math.ceil(items.length / wideCols);\r\n\r\n    // Print matrix\r\n    let i = 0;\r\n    for (let row = 0; row < wideRows; ++row) {\r\n      let rowStr = \"\";\r\n\r\n      // Prepare columns\r\n      for (let col = 0; col < wideCols; ++col) {\r\n        if (i < items.length) {\r\n          let item = items[i++];\r\n          item += \" \".repeat(itemWidth - item.length);\r\n          rowStr += item;\r\n        }\r\n      }\r\n      this.println(rowStr);\r\n    }\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  // Internal API\r\n  /////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n   * Apply prompts to the given input\r\n   */\r\n  applyPrompts(input) {\r\n    const prompt = (this._activePrompt || {}).prompt || \"\";\r\n    const continuationPrompt =\r\n      (this._activePrompt || {}).continuationPrompt || \"\";\r\n\r\n    return prompt + input.replace(/\\n/g, \"\\n\" + continuationPrompt);\r\n  }\r\n\r\n  /**\r\n   * Advances the `offset` as required in order to accompany the prompt\r\n   * additions to the input.\r\n   */\r\n  applyPromptOffset(input, offset) {\r\n    const newInput = this.applyPrompts(input.substr(0, offset));\r\n    return newInput.length;\r\n  }\r\n\r\n  /**\r\n   * Clears the current prompt\r\n   *\r\n   * This function will erase all the lines that display the current prompt\r\n   * and move the cursor in the beginning of the first line of the prompt.\r\n   */\r\n  clearInput() {\r\n    const currentPrompt = this.applyPrompts(this._input);\r\n\r\n    // Get the overall number of lines to clear\r\n    const allRows = countLines(currentPrompt, this._termSize.cols);\r\n\r\n    // Get the line we are currently in\r\n    const promptCursor = this.applyPromptOffset(this._input, this._cursor);\r\n    const { col, row } = offsetToColRow(\r\n      currentPrompt,\r\n      promptCursor,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // First move on the last line\r\n    const moveRows = allRows - row - 1;\r\n    for (var i = 0; i < moveRows; ++i) this.term.write(\"\\x1B[E\");\r\n\r\n    // Clear current input line(s)\r\n    this.term.write(\"\\r\\x1B[K\");\r\n    for (var i = 1; i < allRows; ++i) this.term.write(\"\\x1B[F\\x1B[K\");\r\n  }\r\n\r\n  /**\r\n   * Replace input with the new input given\r\n   *\r\n   * This function clears all the lines that the current input occupies and\r\n   * then replaces them with the new input.\r\n   */\r\n  setInput(newInput, clearInput = true) {\r\n    // Clear current input\r\n    if (clearInput) this.clearInput();\r\n\r\n    // Write the new input lines, including the current prompt\r\n    const newPrompt = this.applyPrompts(newInput);\r\n    this.print(newPrompt);\r\n\r\n    // Trim cursor overflow\r\n    if (this._cursor > newInput.length) {\r\n      this._cursor = newInput.length;\r\n    }\r\n\r\n    // Move the cursor to the appropriate row/col\r\n    const newCursor = this.applyPromptOffset(newInput, this._cursor);\r\n    const newLines = countLines(newPrompt, this._termSize.cols);\r\n    const { col, row } = offsetToColRow(\r\n      newPrompt,\r\n      newCursor,\r\n      this._termSize.cols\r\n    );\r\n    const moveUpRows = newLines - row - 1;\r\n\r\n    this.term.write(\"\\r\");\r\n    for (var i = 0; i < moveUpRows; ++i) this.term.write(\"\\x1B[F\");\r\n    for (var i = 0; i < col; ++i) this.term.write(\"\\x1B[C\");\r\n\r\n    // Replace input\r\n    this._input = newInput;\r\n  }\r\n\r\n  /**\r\n   * This function completes the current input, calls the given callback\r\n   * and then re-displays the prompt.\r\n   */\r\n  printAndRestartPrompt(callback) {\r\n    const cursor = this._cursor;\r\n\r\n    // Complete input\r\n    this.setCursor(this._input.length);\r\n    this.term.write(\"\\r\\n\");\r\n\r\n    // Prepare a function that will resume prompt\r\n    const resume = () => {\r\n      this._cursor = cursor;\r\n      this.setInput(this._input);\r\n    };\r\n\r\n    // Call the given callback to echo something, and if there is a promise\r\n    // returned, wait for the resolution before resuming prompt.\r\n    const ret = callback();\r\n    if (ret == null) {\r\n      resume();\r\n    } else {\r\n      ret.then(resume);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the new cursor position, as an offset on the input string\r\n   *\r\n   * This function:\r\n   * - Calculates the previous and current\r\n   */\r\n  setCursor(newCursor) {\r\n    if (newCursor < 0) newCursor = 0;\r\n    if (newCursor > this._input.length) newCursor = this._input.length;\r\n\r\n    // Apply prompt formatting to get the visual status of the display\r\n    const inputWithPrompt = this.applyPrompts(this._input);\r\n    const inputLines = countLines(inputWithPrompt, this._termSize.cols);\r\n\r\n    // Estimate previous cursor position\r\n    const prevPromptOffset = this.applyPromptOffset(this._input, this._cursor);\r\n    const { col: prevCol, row: prevRow } = offsetToColRow(\r\n      inputWithPrompt,\r\n      prevPromptOffset,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // Estimate next cursor position\r\n    const newPromptOffset = this.applyPromptOffset(this._input, newCursor);\r\n    const { col: newCol, row: newRow } = offsetToColRow(\r\n      inputWithPrompt,\r\n      newPromptOffset,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // Adjust vertically\r\n    if (newRow > prevRow) {\r\n      for (let i = prevRow; i < newRow; ++i) this.term.write(\"\\x1B[B\");\r\n    } else {\r\n      for (let i = newRow; i < prevRow; ++i) this.term.write(\"\\x1B[A\");\r\n    }\r\n\r\n    // Adjust horizontally\r\n    if (newCol > prevCol) {\r\n      for (let i = prevCol; i < newCol; ++i) this.term.write(\"\\x1B[C\");\r\n    } else {\r\n      for (let i = newCol; i < prevCol; ++i) this.term.write(\"\\x1B[D\");\r\n    }\r\n\r\n    // Set new offset\r\n    this._cursor = newCursor;\r\n  }\r\n\r\n  /**\r\n   * Move cursor at given direction\r\n   */\r\n  handleCursorMove(dir) {\r\n    if (dir > 0) {\r\n      const num = Math.min(dir, this._input.length - this._cursor);\r\n      this.setCursor(this._cursor + num);\r\n    } else if (dir < 0) {\r\n      const num = Math.max(dir, -this._cursor);\r\n      this.setCursor(this._cursor + num);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Erase a character at cursor location\r\n   */\r\n  handleCursorErase(backspace) {\r\n    const { _cursor, _input } = this;\r\n    if (backspace) {\r\n      if (_cursor <= 0) return;\r\n      const newInput = _input.substr(0, _cursor - 1) + _input.substr(_cursor);\r\n      this.clearInput();\r\n      this._cursor -= 1;\r\n      this.setInput(newInput, false);\r\n    } else {\r\n      const newInput = _input.substr(0, _cursor) + _input.substr(_cursor + 1);\r\n      this.setInput(newInput);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Insert character at cursor location\r\n   */\r\n  handleCursorInsert(data) {\r\n    const { _cursor, _input } = this;\r\n    const newInput = _input.substr(0, _cursor) + data + _input.substr(_cursor);\r\n    this._cursor += data.length;\r\n    this.setInput(newInput);\r\n  }\r\n\r\n  /**\r\n   * Handle input completion\r\n   */\r\n  handleReadComplete() {\r\n    if (this.history) {\r\n      this.history.push(this._input);\r\n    }\r\n    if (this._activePrompt) {\r\n      this._activePrompt.resolve(this._input);\r\n      this._activePrompt = null;\r\n    }\r\n    this.term.write(\"\\r\\n\");\r\n    this._active = false;\r\n  }\r\n\r\n  /**\r\n   * Handle terminal resize\r\n   *\r\n   * This function clears the prompt using the previous configuration,\r\n   * updates the cached terminal size information and then re-renders the\r\n   * input. This leads (most of the times) into a better formatted input.\r\n   */\r\n  handleTermResize(data) {\r\n    const { rows, cols } = data;\r\n    this.clearInput();\r\n    this._termSize = { cols, rows };\r\n    this.setInput(this._input, false);\r\n  }\r\n\r\n  /**\r\n   * Handle terminal input\r\n   */\r\n  handleTermData(data) {\r\n    if (!this._active) return;\r\n\r\n    // If we have an active character prompt, satisfy it in priority\r\n    if (this._activeCharPrompt != null) {\r\n      this._activeCharPrompt.resolve(data);\r\n      this._activeCharPrompt = null;\r\n      this.term.write(\"\\r\\n\");\r\n      return;\r\n    }\r\n\r\n    // If this looks like a pasted input, expand it\r\n    if (data.length > 3 && data.charCodeAt(0) !== 0x1b) {\r\n      const normData = data.replace(/[\\r\\n]+/g, \"\\r\");\r\n      Array.from(normData).forEach(c => this.handleData(c));\r\n    } else {\r\n      this.handleData(data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle a single piece of information from the terminal.\r\n   */\r\n  handleData(data) {\r\n    if (!this._active) return;\r\n    const ord = data.charCodeAt(0);\r\n    let ofs;\r\n\r\n    // Handle ANSI escape sequences\r\n    if (ord == 0x1b) {\r\n      switch (data.substr(1)) {\r\n        case \"[A\": // Up arrow\r\n          if (this.history) {\r\n            let value = this.history.getPrevious();\r\n            if (value) {\r\n              this.setInput(value);\r\n              this.setCursor(value.length);\r\n            }\r\n          }\r\n          break;\r\n\r\n        case \"[B\": // Down arrow\r\n          if (this.history) {\r\n            let value = this.history.getNext();\r\n            if (!value) value = \"\";\r\n            this.setInput(value);\r\n            this.setCursor(value.length);\r\n          }\r\n          break;\r\n\r\n        case \"[D\": // Left Arrow\r\n          this.handleCursorMove(-1);\r\n          break;\r\n\r\n        case \"[C\": // Right Arrow\r\n          this.handleCursorMove(1);\r\n          break;\r\n\r\n        case \"[3~\": // Delete\r\n          this.handleCursorErase(false);\r\n          break;\r\n\r\n        case \"[F\": // End\r\n          this.setCursor(this._input.length);\r\n          break;\r\n\r\n        case \"[H\": // Home\r\n          this.setCursor(0);\r\n          break;\r\n\r\n        case \"b\": // ALT + LEFT\r\n          ofs = closestLeftBoundary(this._input, this._cursor);\r\n          if (ofs != null) this.setCursor(ofs);\r\n          break;\r\n\r\n        case \"f\": // ALT + RIGHT\r\n          ofs = closestRightBoundary(this._input, this._cursor);\r\n          if (ofs != null) this.setCursor(ofs);\r\n          break;\r\n\r\n        case \"\\x7F\": // CTRL + BACKSPACE\r\n          ofs = closestLeftBoundary(this._input, this._cursor);\r\n          if (ofs != null) {\r\n            this.setInput(\r\n              this._input.substr(0, ofs) + this._input.substr(this._cursor)\r\n            );\r\n            this.setCursor(ofs);\r\n          }\r\n          break;\r\n      }\r\n\r\n      // Handle special characters\r\n    } else if (ord < 32 || ord === 0x7f) {\r\n      switch (data) {\r\n        case \"\\r\": // ENTER\r\n          if (isIncompleteInput(this._input)) {\r\n            this.handleCursorInsert(\"\\n\");\r\n          } else {\r\n            this.handleReadComplete();\r\n          }\r\n          break;\r\n\r\n        case \"\\x7F\": // BACKSPACE\r\n          this.handleCursorErase(true);\r\n          break;\r\n\r\n        case \"\\t\": // TAB\r\n          if (this._autocompleteHandlers.length > 0) {\r\n            const inputFragment = this._input.substr(0, this._cursor);\r\n            const hasTailingSpace = hasTailingWhitespace(inputFragment);\r\n            const candidates = collectAutocompleteCandidates(\r\n              this._autocompleteHandlers,\r\n              inputFragment\r\n            );\r\n\r\n            // Sort candidates\r\n            candidates.sort();\r\n\r\n            // Depending on the number of candidates, we are handing them in\r\n            // a different way.\r\n            if (candidates.length === 0) {\r\n              // No candidates? Just add a space if there is none already\r\n              if (!hasTailingSpace) {\r\n                this.handleCursorInsert(\" \");\r\n              }\r\n            } else if (candidates.length === 1) {\r\n              // Just a single candidate? Complete\r\n              const lastToken = getLastToken(inputFragment);\r\n              this.handleCursorInsert(\r\n                candidates[0].substr(lastToken.length) + \" \"\r\n              );\r\n            } else if (candidates.length <= this.maxAutocompleteEntries) {\r\n\r\n              // search for a shared fragement\r\n              const sameFragment = getSharedFragment(inputFragment, candidates);\r\n              \r\n              // if there's a shared fragement between the candidates\r\n              // print complete the shared fragment\r\n              if (sameFragment) {\r\n                const lastToken = getLastToken(inputFragment);\r\n                this.handleCursorInsert(\r\n                  sameFragment.substr(lastToken.length)\r\n                );\r\n              }\r\n\r\n              // If we are less than maximum auto-complete candidates, print\r\n              // them to the user and re-start prompt\r\n              this.printAndRestartPrompt(() => {\r\n                this.printWide(candidates);\r\n              });\r\n            } else {\r\n              // If we have more than maximum auto-complete candidates, print\r\n              // them only if the user acknowledges a warning\r\n              this.printAndRestartPrompt(() =>\r\n                this.readChar(\r\n                  `Display all ${candidates.length} possibilities? (y or n)`\r\n                ).then(yn => {\r\n                  if (yn == \"y\" || yn == \"Y\") {\r\n                    this.printWide(candidates);\r\n                  }\r\n                })\r\n              );\r\n            }\r\n          } else {\r\n            this.handleCursorInsert(\"    \");\r\n          }\r\n          break;\r\n\r\n        case \"\\x03\": // CTRL+C\r\n          this.setCursor(this._input.length);\r\n          this.term.write(\"^C\\r\\n\" + ((this._activePrompt || {}).prompt || \"\"));\r\n          this._input = \"\";\r\n          this._cursor = 0;\r\n          if (this.history) this.history.rewind();\r\n          break;\r\n      }\r\n\r\n      // Handle visible characters\r\n    } else {\r\n      this.handleCursorInsert(data);\r\n    }\r\n  }\r\n}\r\n","import LocalEchoController from \"./lib/LocalEchoController\";\r\nexport { HistoryController } from './lib/HistoryController';\r\n\r\nexport default LocalEchoController;\r\n"],"names":["exports","parse","CONTROL","join","controlRE","RegExp","META","hash","TOKEN","i","Math","random","toString","startsWithToken","module","s","env","opts","mapped","string","BS","escape","chunker","matches","r","matchObj","origIndex","lastIndex","exec","push","index","matchAll","length","commented","map","match","test","op","quote","esc","out","isGlob","c","charAt","parseEnvVar","commentObj","comment","slice","pattern","varend","varname","char","Error","indexOf","slicedFromI","pre","key","JSON","stringify","getVar","reduce","prev","arg","concat","parseInternal","acc","xs","split","filter","Boolean","x","replace","String","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","HistoryController","size","_classCallCheck","this","entries","cursor","value","entry","trim","pop","idx","max","min","wordBoundaries","input","leftSide","arguments","words","rx","closestLeftBoundary","offset","found","reverse","find","offsetToColRow","maxCols","row","col","countLines","hasTailingWhitespace","getLastToken","getSharedFragment","fragment","candidates","oldFragment","startsWith","LocalEchoController","term","options","_handleTermData","handleTermData","bind","_handleTermResize","handleTermResize","history","historySize","maxAutocompleteEntries","_autocompleteHandlers","_active","_input","_cursor","_activePrompt","_activeCharPrompt","_termSize","cols","rows","_disposables","loadAddon","attach","detach","off","forEach","dispose","on","onData","onResize","fn","_len","args","Array","_key","findIndex","e","splice","prompt","_this","continuationPrompt","Promise","resolve","reject","write","_this2","reason","message","print","normInput","items","padding","println","itemWidth","width","item","wideCols","floor","wideRows","ceil","rowStr","repeat","applyPrompts","substr","currentPrompt","allRows","_offsetToColRow","applyPromptOffset","moveRows","newInput","clearInput","newPrompt","newCursor","newLines","_offsetToColRow2","moveUpRows","callback","_this3","setCursor","resume","setInput","ret","then","inputWithPrompt","_offsetToColRow3","prevCol","prevRow","_offsetToColRow4","newCol","newRow","dir","num","backspace","data","_this4","charCodeAt","normData","from","handleData","_this5","ofs","ord","getPrevious","getNext","handleCursorMove","handleCursorErase","endsWith","isIncompleteInput","handleReadComplete","handleCursorInsert","inputFragment","hasTailingSpace","callbacks","tokens","expr","_ref","apply","console","error","txt","collectAutocompleteCandidates","sort","lastToken","sameFragment","printAndRestartPrompt","printWide","readChar","yn","rewind"],"sourceRoot":""}